<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connected Graph Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.9/dist/vis-network.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            padding: 20px;
        }
        h1 { text-align: center; margin-bottom: 20px; }
        .controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: end;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .field { display: flex; flex-direction: column; gap: 4px; }
        .field label { font-size: 14px; font-weight: 600; }
        .field input {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 16px;
            width: 140px;
        }
        button {
            padding: 8px 24px;
            background: #4a90d9;
            color: #fff;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            height: 38px;
        }
        button:hover { background: #357abd; }
        button:disabled { background: #aaa; cursor: not-allowed; }
        #graph-container {
            width: 100%;
            height: calc(100vh - 180px);
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .info {
            text-align: center;
            margin-bottom: 10px;
            font-size: 14px;
            color: #666;
        }
        .error { color: #d9534f; text-align: center; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Connected Graph Generator</h1>
    <div class="controls">
        <div class="field">
            <label for="vertices">頂点数 (必須)</label>
            <input type="number" id="vertices" min="3" max="200" value="10">
        </div>
        <div class="field">
            <label for="edges">エッジ数 (空=ランダム)</label>
            <input type="number" id="edges" min="0" placeholder="auto">
        </div>
        <button id="generate-btn" onclick="generate()">生成</button>
        <button id="split-btn" onclick="splitAll()">閉領域分割</button>
    </div>
    <div class="controls">
        <div class="field">
            <label for="save-name">保存名</label>
            <input type="text" id="save-name" placeholder="example-graph">
        </div>
        <button id="save-btn" onclick="saveGraph()">保存</button>
        <div class="field">
            <label for="load-select">読み込み</label>
            <select id="load-select"></select>
        </div>
        <button id="load-btn" onclick="loadGraph()">読み込み</button>
        <button id="refresh-btn" onclick="refreshSavedList()">一覧更新</button>
    </div>
    <div id="info" class="info"></div>
    <div id="error" class="error"></div>
    <div id="graph-container"></div>

    <script>
        let network = null;
        let currentGraph = null;
        let edgesDataSet = null;
        let edgeKeyToId = new Map();
        let facePolygons = null;
        let faceColors = null;
        const DEFAULT_EDGE_COLOR = '#999';

        async function generate() {
            const btn = document.getElementById('generate-btn');
            const errorDiv = document.getElementById('error');
            const infoDiv = document.getElementById('info');
            errorDiv.textContent = '';
            infoDiv.textContent = '';

            const numVertices = parseInt(document.getElementById('vertices').value);
            if (isNaN(numVertices) || numVertices < 3) {
                errorDiv.textContent = '頂点数を3以上の整数で入力してください';
                return;
            }

            const edgesInput = document.getElementById('edges').value.trim();
            const body = { num_vertices: numVertices };
            if (edgesInput !== '') {
                body.num_edges = parseInt(edgesInput);
                if (isNaN(body.num_edges) || body.num_edges < 0) {
                    errorDiv.textContent = 'エッジ数は0以上の整数で入力してください';
                    return;
                }
            }

            btn.disabled = true;
            btn.textContent = '生成中...';

            try {
                const res = await fetch('/graph/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                });

                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.detail || 'API error');
                }

                const data = await res.json();
                infoDiv.textContent = `頂点数: ${data.num_vertices} / エッジ数: ${data.num_edges}`;
                currentGraph = data;
                renderGraph(data);
            } catch (e) {
                errorDiv.textContent = e.message;
            } finally {
                btn.disabled = false;
                btn.textContent = '生成';
            }
        }

        function renderGraph(data) {
            const n = data.num_vertices;
            const positions = data.positions;
            const container = document.getElementById('graph-container');
            const scale = 800;

            // 座標の範囲を取得してスケーリング
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (let i = 0; i < n; i++) {
                const p = positions[i];
                minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
            }
            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;

            const nodes = new vis.DataSet(
                Array.from({ length: n }, (_, i) => {
                    const p = positions[i];
                    return {
                        id: i,
                        label: String(i),
                        x: ((p.x - minX) / rangeX - 0.5) * scale,
                        y: ((p.y - minY) / rangeY - 0.5) * scale,
                        fixed: false,
                    };
                })
            );

            const edges = new vis.DataSet(
                data.edges.map((e, i) => ({
                    id: i,
                    from: e.source,
                    to: e.target,
                }))
            );

            const options = {
                nodes: {
                    shape: 'dot',
                    size: 16,
                    font: { size: 14 },
                    color: { background: '#4a90d9', border: '#357abd' },
                },
                edges: {
                    color: { color: '#999' },
                    width: 1.5,
                    smooth: false,
                },
                physics: { enabled: false },
                interaction: { hover: true, zoomView: true, dragView: true },
            };

            if (network) network.destroy();
            network = new vis.Network(container, { nodes, edges }, options);
            edgesDataSet = edges;
            edgeKeyToId = new Map();
            facePolygons = null;
            faceColors = null;
            data.edges.forEach((e, i) => {
                const a = Math.min(e.source, e.target);
                const b = Math.max(e.source, e.target);
                edgeKeyToId.set(`${a}-${b}`, i);
            });

            network.on('beforeDrawing', drawFaces);
            network.on('dragEnd', syncPositionsFromNetwork);
        }

        async function splitAll() {
            const errorDiv = document.getElementById('error');
            const infoDiv = document.getElementById('info');
            errorDiv.textContent = '';
            if (!currentGraph) {
                errorDiv.textContent = '先にグラフを生成してください';
                return;
            }

            try {
                const res = await fetch('/graph/faces', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        num_vertices: currentGraph.num_vertices,
                        edges: currentGraph.edges,
                        positions: currentGraph.positions,
                    }),
                });

                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.detail || 'API error');
                }

                const data = await res.json();
                const facesAll = data.faces || [];
                const outerIdx = data.outer_face_index;
                let faces = facesAll;
                if (outerIdx !== null && outerIdx !== undefined) {
                    faces = facesAll.filter((_, i) => i !== outerIdx);
                }

                if (faces.length === 0) {
                    errorDiv.textContent = '分割できる面がありません';
                    return;
                }

                facePolygons = faces;
                const assignment = assignRegionsGreedyBoundary(
                    facesAll,
                    outerIdx,
                    currentGraph.positions
                );
                const k = assignment.regionCount;
                const regionColors = Array.from({ length: k }, (_, i) => randomPastel(i + 1));
                faceColors = assignment.regions.map(regionId => regionColors[regionId]);
                infoDiv.textContent = `領域数: ${k} / 面数: ${faces.length}（外面除外）`;
                network.redraw();
            } catch (e) {
                errorDiv.textContent = e.message;
            }
        }

        async function refreshSavedList() {
            const select = document.getElementById('load-select');
            select.innerHTML = '';
            try {
                const res = await fetch('/graph/list');
                if (!res.ok) throw new Error('API error');
                const data = await res.json();
                const files = data.files || [];
                files.forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    select.appendChild(opt);
                });
            } catch (e) {
                // no-op
            }
        }

        async function saveGraph() {
            const errorDiv = document.getElementById('error');
            const infoDiv = document.getElementById('info');
            errorDiv.textContent = '';
            if (!currentGraph) {
                errorDiv.textContent = '先にグラフを生成してください';
                return;
            }
            const name = document.getElementById('save-name').value.trim();
            if (!name) {
                errorDiv.textContent = '保存名を入力してください';
                return;
            }
            try {
                syncPositionsFromNetwork();
                const res = await fetch('/graph/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name,
                        num_vertices: currentGraph.num_vertices,
                        edges: currentGraph.edges,
                        positions: currentGraph.positions,
                    }),
                });
                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.detail || 'API error');
                }
                const data = await res.json();
                infoDiv.textContent = `保存しました: ${data.name}`;
                await refreshSavedList();
            } catch (e) {
                errorDiv.textContent = e.message;
            }
        }

        async function loadGraph() {
            const errorDiv = document.getElementById('error');
            const infoDiv = document.getElementById('info');
            errorDiv.textContent = '';
            const select = document.getElementById('load-select');
            const name = select.value;
            if (!name) {
                errorDiv.textContent = '読み込み対象を選択してください';
                return;
            }
            try {
                const res = await fetch(`/graph/load/${encodeURIComponent(name)}`);
                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.detail || 'API error');
                }
                const data = await res.json();
                currentGraph = data;
                renderGraph(data);
                infoDiv.textContent = `読み込みました: ${name}`;
            } catch (e) {
                errorDiv.textContent = e.message;
            }
        }

        function drawFaces(ctx) {
            if (!facePolygons || !faceColors || !network) return;
            const positions = network.getPositions();
            ctx.save();
            ctx.globalAlpha = 0.45;
            for (let i = 0; i < facePolygons.length; i++) {
                const face = facePolygons[i];
                const color = faceColors[i];
                if (!face || face.length < 3) continue;
                const p0 = positions[face[0]];
                if (!p0) continue;
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                for (let j = 1; j < face.length; j++) {
                    const p = positions[face[j]];
                    if (!p) continue;
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
            }
            ctx.restore();
        }

        function randomPastel(seed) {
            const x = Math.sin(seed * 999 + 13) * 10000;
            const r = Math.floor(180 + (x - Math.floor(x)) * 60);
            const g = Math.floor(180 + (Math.sin(seed * 123 + 7) + 1) * 30);
            const b = Math.floor(180 + (Math.sin(seed * 321 + 11) + 1) * 30);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function randomRegionCount(minK, maxK) {
            if (maxK <= minK) return minK;
            return Math.floor(Math.random() * (maxK - minK + 1)) + minK;
        }

        function assignRegionsBySharedEdges(faces, desiredCount) {
            const faceCount = faces.length;
            const regions = new Array(faceCount).fill(-1);

            // Build adjacency by shared edges
            const edgeToFaces = new Map();
            for (let i = 0; i < faceCount; i++) {
                const face = faces[i];
                for (let j = 0; j < face.length; j++) {
                    const a = face[j];
                    const b = face[(j + 1) % face.length];
                    const key = `${Math.min(a, b)}-${Math.max(a, b)}`;
                    if (!edgeToFaces.has(key)) edgeToFaces.set(key, []);
                    edgeToFaces.get(key).push(i);
                }
            }

            const adj = Array.from({ length: faceCount }, () => new Set());
            edgeToFaces.forEach(list => {
                if (list.length < 2) return;
                for (let i = 0; i < list.length; i++) {
                    for (let j = i + 1; j < list.length; j++) {
                        adj[list[i]].add(list[j]);
                        adj[list[j]].add(list[i]);
                    }
                }
            });

            // Find connected components in face adjacency graph
            const components = [];
            const visited = new Array(faceCount).fill(false);
            for (let i = 0; i < faceCount; i++) {
                if (visited[i]) continue;
                const stack = [i];
                visited[i] = true;
                const comp = [];
                while (stack.length) {
                    const v = stack.pop();
                    comp.push(v);
                    adj[v].forEach(nb => {
                        if (!visited[nb]) {
                            visited[nb] = true;
                            stack.push(nb);
                        }
                    });
                }
                components.push(comp);
            }

            const compCount = components.length;
            const maxK = faceCount;
            let regionCount;
            if (desiredCount !== null && desiredCount !== undefined) {
                regionCount = Math.max(compCount, Math.min(maxK, desiredCount));
            } else {
                regionCount = randomRegionCount(compCount, maxK);
            }

            // Allocate region counts per component (at least 1 each, capped by size)
            const compRegions = components.map(c => 1);
            let remaining = regionCount - compCount;
            while (remaining > 0) {
                const idx = Math.floor(Math.random() * compRegions.length);
                if (compRegions[idx] < components[idx].length) {
                    compRegions[idx]++;
                    remaining--;
                }
            }

            // Assign regions within each component by BFS growth
            let regionBase = 0;
            for (let ci = 0; ci < components.length; ci++) {
                const comp = components[ci];
                const k = compRegions[ci];

                // shuffle faces in component
                const compFaces = comp.slice();
                for (let i = compFaces.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [compFaces[i], compFaces[j]] = [compFaces[j], compFaces[i]];
                }

                const seeds = compFaces.slice(0, k);
                const frontiers = Array.from({ length: k }, () => []);
                for (let r = 0; r < k; r++) {
                    const f = seeds[r];
                    regions[f] = regionBase + r;
                    frontiers[r].push(f);
                }

                let assigned = k;
                while (assigned < comp.length) {
                    let progressed = false;
                    for (let r = 0; r < k; r++) {
                        if (frontiers[r].length === 0) continue;
                        const current = frontiers[r].shift();
                        const neighbors = Array.from(adj[current]).filter(v => regions[v] === -1);
                        for (let i = neighbors.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [neighbors[i], neighbors[j]] = [neighbors[j], neighbors[i]];
                        }
                        for (const nb of neighbors) {
                            regions[nb] = regionBase + r;
                            frontiers[r].push(nb);
                            assigned++;
                            progressed = true;
                        }
                    }

                    if (!progressed) {
                        // Fallback: assign any remaining face to a random region to avoid infinite loop
                        const remainingIdx = comp.find(v => regions[v] === -1);
                        if (remainingIdx === undefined) break;
                        const r = Math.floor(Math.random() * k);
                        regions[remainingIdx] = regionBase + r;
                        frontiers[r].push(remainingIdx);
                        assigned++;
                    }
                }

                regionBase += k;
            }

            return { regions, regionCount };
        }

        function assignRegionsGreedyBoundary(facesAll, outerIdx, positions) {
            const faceCountAll = facesAll.length;
            if (outerIdx === null || outerIdx === undefined) {
                return assignRegionsGreedyNoCycles(facesAll, positions);
            }

            const internalIds = [];
            for (let i = 0; i < faceCountAll; i++) {
                if (i !== outerIdx) internalIds.push(i);
            }
            const m = internalIds.length;
            const idToInternal = new Map();
            internalIds.forEach((id, idx) => idToInternal.set(id, idx));

            const outerVertices = new Set(facesAll[outerIdx] || []);

            const edgeToFaces = new Map();
            for (let i = 0; i < faceCountAll; i++) {
                const face = facesAll[i];
                for (let j = 0; j < face.length; j++) {
                    const a = face[j];
                    const b = face[(j + 1) % face.length];
                    const key = `${Math.min(a, b)}-${Math.max(a, b)}`;
                    if (!edgeToFaces.has(key)) edgeToFaces.set(key, []);
                    edgeToFaces.get(key).push(i);
                }
            }

            const adj = Array.from({ length: m }, () => new Set());
            edgeToFaces.forEach(list => {
                if (list.length < 2) return;
                for (let i = 0; i < list.length; i++) {
                    for (let j = i + 1; j < list.length; j++) {
                        const a = list[i];
                        const b = list[j];
                        if (a === outerIdx || b === outerIdx) continue;
                        const ia = idToInternal.get(a);
                        const ib = idToInternal.get(b);
                        adj[ia].add(ib);
                        adj[ib].add(ia);
                    }
                }
            });

            const facesInternal = internalIds.map(id => facesAll[id]);
            const areas = facesInternal.map(face => Math.abs(polygonArea(face, positions)));

            // incident internal faces per vertex
            const incident = new Map();
            for (let i = 0; i < m; i++) {
                const face = facesInternal[i];
                for (const v of face) {
                    if (!incident.has(v)) incident.set(v, new Set());
                    incident.get(v).add(i);
                }
            }

            const regions = new Array(m).fill(-1);
            const unassigned = new Set(Array.from({ length: m }, (_, i) => i));

            function wouldCreateInteriorVertex(regionFaces, candidate) {
                const next = new Set(regionFaces);
                next.add(candidate);
                const face = facesInternal[candidate];
                for (const v of face) {
                    if (outerVertices.has(v)) continue;
                    const inc = incident.get(v);
                    if (!inc) continue;
                    let allIn = true;
                    inc.forEach(f => {
                        if (!next.has(f)) allIn = false;
                    });
                    if (allIn) return true;
                }
                return false;
            }

            function boundaryVertexCount(regionFaces) {
                const verts = new Set();
                regionFaces.forEach(f => {
                    facesInternal[f].forEach(v => verts.add(v));
                });
                let count = 0;
                verts.forEach(v => {
                    if (outerVertices.has(v)) {
                        count++;
                        return;
                    }
                    const inc = incident.get(v);
                    let allIn = true;
                    inc.forEach(f => {
                        if (!regionFaces.has(f)) allIn = false;
                    });
                    if (!allIn) count++;
                });
                return count;
            }

            let regionId = 0;
            while (unassigned.size > 0) {
                // seed: unassigned face with largest area
                let seed = -1;
                let bestArea = -1;
                unassigned.forEach(i => {
                    if (areas[i] > bestArea) {
                        bestArea = areas[i];
                        seed = i;
                    }
                });
                if (seed === -1) break;

                const regionFaces = new Set([seed]);
                regions[seed] = regionId;
                unassigned.delete(seed);

                let grew = true;
                while (grew) {
                    grew = false;
                    let bestCandidate = -1;
                    let bestBoundary = -1;
                    let bestAreaLocal = -1;

                    const candidates = [];
                    unassigned.forEach(i => {
                        let adjacent = false;
                        adj[i].forEach(nb => {
                            if (regionFaces.has(nb)) adjacent = true;
                        });
                        if (adjacent) candidates.push(i);
                    });

                    for (const cand of candidates) {
                        if (wouldCreateInteriorVertex(regionFaces, cand)) continue;
                        const next = new Set(regionFaces);
                        next.add(cand);
                        const bcount = boundaryVertexCount(next);
                        if (bcount > bestBoundary || (bcount === bestBoundary && areas[cand] > bestAreaLocal)) {
                            bestBoundary = bcount;
                            bestAreaLocal = areas[cand];
                            bestCandidate = cand;
                        }
                    }

                    if (bestCandidate !== -1) {
                        regionFaces.add(bestCandidate);
                        regions[bestCandidate] = regionId;
                        unassigned.delete(bestCandidate);
                        grew = true;
                    }
                }

                regionId++;
            }

            return { regions, regionCount: regionId };
        }

        function assignRegionsGreedyNoCycles(faces, positions) {
            const faceCount = faces.length;
            const regions = new Array(faceCount).fill(-1);

            const edgeToFaces = new Map();
            for (let i = 0; i < faceCount; i++) {
                const face = faces[i];
                for (let j = 0; j < face.length; j++) {
                    const a = face[j];
                    const b = face[(j + 1) % face.length];
                    const key = `${Math.min(a, b)}-${Math.max(a, b)}`;
                    if (!edgeToFaces.has(key)) edgeToFaces.set(key, []);
                    edgeToFaces.get(key).push(i);
                }
            }

            const adj = Array.from({ length: faceCount }, () => new Set());
            edgeToFaces.forEach(list => {
                if (list.length < 2) return;
                for (let i = 0; i < list.length; i++) {
                    for (let j = i + 1; j < list.length; j++) {
                        adj[list[i]].add(list[j]);
                        adj[list[j]].add(list[i]);
                    }
                }
            });

            const areas = faces.map(face => Math.abs(polygonArea(face, positions)));
            const unassigned = new Set(Array.from({ length: faceCount }, (_, i) => i));

            let regionId = 0;
            while (unassigned.size > 0) {
                let seed = -1;
                let bestArea = -1;
                unassigned.forEach(i => {
                    if (areas[i] > bestArea) {
                        bestArea = areas[i];
                        seed = i;
                    }
                });
                if (seed === -1) break;

                regions[seed] = regionId;
                unassigned.delete(seed);

                let grew = true;
                while (grew) {
                    grew = false;
                    let bestFace = -1;
                    let bestFaceArea = -1;
                    unassigned.forEach(i => {
                        let neighborCount = 0;
                        adj[i].forEach(nb => {
                            if (regions[nb] === regionId) neighborCount++;
                        });
                        if (neighborCount === 0) return;
                        if (neighborCount >= 2) return;
                        if (areas[i] > bestFaceArea) {
                            bestFaceArea = areas[i];
                            bestFace = i;
                        }
                    });

                    if (bestFace !== -1) {
                        regions[bestFace] = regionId;
                        unassigned.delete(bestFace);
                        grew = true;
                    }
                }

                regionId++;
            }

            return { regions, regionCount: regionId };
        }

        function polygonArea(face, positions) {
            let area = 0;
            for (let i = 0; i < face.length; i++) {
                const a = positions[face[i]] ?? positions[String(face[i])];
                const b = positions[face[(i + 1) % face.length]] ?? positions[String(face[(i + 1) % face.length])];
                area += a.x * b.y - b.x * a.y;
            }
            return area * 0.5;
        }

        function syncPositionsFromNetwork() {
            if (!network || !currentGraph) return;
            const positions = network.getPositions();
            const updated = {};
            Object.keys(positions).forEach(key => {
                const id = parseInt(key, 10);
                const p = positions[key];
                updated[id] = { x: p.x, y: p.y };
            });
            currentGraph.positions = updated;
        }

        refreshSavedList();
    </script>
</body>
</html>
