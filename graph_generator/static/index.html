<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connected Graph Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.9/dist/vis-network.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #070b17;
            --bg-secondary: #0e1424;
            --bg-tertiary: #162039;
            --text: #dbe8ff;
            --text-muted: #8ea4cc;
            --border: #253458;
            --border-input: #31466f;
            --btn-primary-bg: #2e69d1;
            --btn-primary-hover: #3e7ae4;
            --btn-secondary-bg: #111b31;
            --btn-secondary-hover: #1a2847;
            --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
        }
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            padding: 24px;
        }
        h1 {
            text-align: center;
            margin-bottom: 8px;
            font-size: 42px;
            letter-spacing: -0.02em;
            background: linear-gradient(90deg, #8fb8ff, #c0d6ff, #91ffd8);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        .subtitle {
            text-align: center;
            color: var(--text-muted);
            margin-bottom: 18px;
            font-size: 14px;
        }
        .app-shell {
            max-width: 1400px;
            margin: 0 auto;
        }
        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px;
            box-shadow: var(--card-shadow);
            margin-bottom: 14px;
        }
        .controls {
            display: flex;
            gap: 12px;
            justify-content: flex-start;
            align-items: end;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .field { display: flex; flex-direction: column; gap: 4px; }
        .field label { font-size: 13px; font-weight: 600; color: var(--text-muted); }
        .field input,
        .field select {
            padding: 8px 12px;
            border: 1px solid var(--border-input);
            border-radius: 6px;
            font-size: 15px;
            width: 140px;
            background: #0a1224;
            color: var(--text);
        }
        button {
            padding: 8px 24px;
            background: var(--btn-primary-bg);
            color: #fff;
            border: 1px solid transparent;
            border-radius: 6px;
            font-size: 15px;
            cursor: pointer;
            height: 38px;
            box-shadow: 0 0 0 rgba(0, 0, 0, 0);
            transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.08s ease;
        }
        button:hover { background: var(--btn-primary-hover); box-shadow: 0 0 18px rgba(62, 122, 228, 0.24); }
        button:active { transform: translateY(1px); }
        button:disabled { background: #aaa; cursor: not-allowed; }
        #refresh-btn,
        #load-btn,
        #save-btn {
            background: var(--btn-secondary-bg);
            color: var(--text);
            border-color: var(--border-input);
        }
        #refresh-btn:hover,
        #load-btn:hover,
        #save-btn:hover {
            background: var(--btn-secondary-hover);
        }
        #graph-container {
            width: 100%;
            height: calc(100vh - 300px);
            min-height: 560px;
            background: radial-gradient(circle at 25% 15%, #17274a 0%, #0c1427 45%, #090f1e 100%);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: var(--card-shadow);
        }
        .info {
            text-align: center;
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--text-muted);
        }
        .error { color: #d9534f; text-align: center; margin-bottom: 10px; }
        @media (max-width: 900px) {
            body { padding: 12px; }
            h1 { font-size: 34px; }
            #graph-container {
                height: calc(100vh - 360px);
                min-height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="app-shell">
        <h1>Connected Graph Generator</h1>
        <p class="subtitle">Naoto Graph Workflow</p>
        <div class="panel">
            <div class="controls">
                <div class="field">
                    <label for="vertices">Vertices (required)</label>
                    <input type="number" id="vertices" min="3" max="200" value="10">
                </div>
                <div class="field">
                    <label for="edges">Edges (blank = random)</label>
                    <input type="number" id="edges" min="0" placeholder="auto">
                </div>
                <button id="generate-btn" onclick="generate()">Generate</button>
                <button id="split-btn" onclick="splitAll()">Split Regions</button>
            </div>
            <div class="controls">
                <div class="field">
                    <label for="save-name">Save Name</label>
                    <input type="text" id="save-name" placeholder="example-graph">
                </div>
                <button id="save-btn" onclick="saveGraph()">Save</button>
                <div class="field">
                    <label for="load-select">Load</label>
                    <select id="load-select"></select>
                </div>
                <button id="load-btn" onclick="loadGraph()">Load</button>
                <button id="refresh-btn" onclick="refreshSavedList()">Refresh List</button>
            </div>
            <div class="controls">
                <div class="field">
                    <label for="seed-face">Seed Region Index</label>
                    <input type="number" id="seed-face" min="0" placeholder="0">
                </div>
                <div class="field">
                    <label for="seed-orientation">Orientation</label>
                    <select id="seed-orientation">
                        <option value="cw">CW</option>
                        <option value="ccw">CCW</option>
                    </select>
                </div>
                <button id="orient-btn" onclick="showOrientation()">Show Orientation</button>
                <button id="optimize-btn" onclick="optimizeInternalOrientation()">Optimize Internal Direction</button>
            </div>
        </div>
        <div id="info" class="info"></div>
        <div id="error" class="error"></div>
        <div id="graph-container"></div>
    </div>

    <script>
        let network = null;
        let currentGraph = null;
        let edgesDataSet = null;
        let edgeKeyToId = new Map();
        let facePolygons = null;
        let faceColors = null;
        let orientedFaces = null;
        let orientedOuterIdx = null;
        let showOrientationArrows = false;
        let currentFaceRegions = null;
        let latestFacesAll = null;
        let latestInternalFaceIds = null;
        let regionBoundaryArrows = null;
        let optimizedInternalArrows = null;
        let animationFrameId = null;
        const DEFAULT_EDGE_COLOR = '#999';

        async function generate() {
            const btn = document.getElementById('generate-btn');
            const errorDiv = document.getElementById('error');
            const infoDiv = document.getElementById('info');
            errorDiv.textContent = '';
            infoDiv.textContent = '';

            const numVertices = parseInt(document.getElementById('vertices').value);
            if (isNaN(numVertices) || numVertices < 3) {
                errorDiv.textContent = 'Please enter an integer of 3 or greater for vertices';
                return;
            }

            const edgesInput = document.getElementById('edges').value.trim();
            const body = { num_vertices: numVertices };
            if (edgesInput !== '') {
                body.num_edges = parseInt(edgesInput);
                if (isNaN(body.num_edges) || body.num_edges < 0) {
                    errorDiv.textContent = 'Please enter an integer of 0 or greater for edges';
                    return;
                }
            }

            btn.disabled = true;
            btn.textContent = 'Generating...';

            try {
                const res = await fetch('/graph/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                });

                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.detail || 'API error');
                }

                const data = await res.json();
                infoDiv.textContent = `Vertices: ${data.num_vertices} / Edges: ${data.num_edges}`;
                currentGraph = data;
                renderGraph(data);
            } catch (e) {
                errorDiv.textContent = e.message;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Generate';
            }
        }

        function renderGraph(data) {
            const n = data.num_vertices;
            const positions = data.positions;
            const container = document.getElementById('graph-container');
            const scale = 800;

            // 座標の範囲を取得してスケーリング
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (let i = 0; i < n; i++) {
                const p = positions[i];
                minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
            }
            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;

            const nodes = new vis.DataSet(
                Array.from({ length: n }, (_, i) => {
                    const p = positions[i];
                    return {
                        id: i,
                        label: String(i),
                        x: ((p.x - minX) / rangeX - 0.5) * scale,
                        y: ((p.y - minY) / rangeY - 0.5) * scale,
                        fixed: false,
                    };
                })
            );

            const edges = new vis.DataSet(
                data.edges.map((e, i) => ({
                    id: i,
                    from: e.source,
                    to: e.target,
                }))
            );

            const options = {
                nodes: {
                    shape: 'dot',
                    size: 16,
                    font: { size: 14, color: '#dbe8ff' },
                    color: { background: '#5a8fe8', border: '#7fb2ff' },
                },
                edges: {
                    color: { color: '#6680a8' },
                    width: 1.5,
                    smooth: false,
                },
                physics: { enabled: false },
                interaction: { hover: true, zoomView: true, dragView: true },
            };

            if (network) network.destroy();
            network = new vis.Network(container, { nodes, edges }, options);
            edgesDataSet = edges;
            edgeKeyToId = new Map();
            facePolygons = null;
            faceColors = null;
            orientedFaces = null;
            orientedOuterIdx = null;
            showOrientationArrows = false;
            currentFaceRegions = null;
            latestFacesAll = null;
            latestInternalFaceIds = null;
            regionBoundaryArrows = null;
            optimizedInternalArrows = null;
            data.edges.forEach((e, i) => {
                const a = Math.min(e.source, e.target);
                const b = Math.max(e.source, e.target);
                edgeKeyToId.set(`${a}-${b}`, i);
            });

            network.on('beforeDrawing', drawFaces);
            network.on('afterDrawing', drawOrientationOverlay);
            network.on('dragEnd', syncPositionsFromNetwork);
            ensureArrowAnimation();
        }

        async function splitAll() {
            const errorDiv = document.getElementById('error');
            const infoDiv = document.getElementById('info');
            errorDiv.textContent = '';
            if (!currentGraph) {
                errorDiv.textContent = 'Please generate a graph first';
                return;
            }

            try {
                const res = await fetch('/graph/faces', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        num_vertices: currentGraph.num_vertices,
                        edges: currentGraph.edges,
                        positions: currentGraph.positions,
                    }),
                });

                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.detail || 'API error');
                }

                const data = await res.json();
                const facesAll = data.faces || [];
                const outerIdx = data.outer_face_index;
                let faces = facesAll;
                const internalFaceIds = [];
                if (outerIdx !== null && outerIdx !== undefined) {
                    faces = facesAll.filter((_, i) => i !== outerIdx);
                }
                for (let i = 0; i < facesAll.length; i++) {
                    if (i !== outerIdx) internalFaceIds.push(i);
                }

                if (faces.length === 0) {
                    errorDiv.textContent = 'No splittable faces were found';
                    return;
                }

                facePolygons = faces;
                const assignment = assignRegionsGreedyBoundary(
                    facesAll,
                    outerIdx,
                    currentGraph.positions
                );
                const k = assignment.regionCount;
                const regionColors = Array.from({ length: k }, (_, i) => randomPastel(i + 1));
                faceColors = assignment.regions.map(regionId => regionColors[regionId]);
                currentFaceRegions = assignment.regions;
                latestFacesAll = facesAll;
                latestInternalFaceIds = internalFaceIds;
                showOrientationArrows = false;
                regionBoundaryArrows = null;
                optimizedInternalArrows = null;
                infoDiv.textContent = `Regions: ${k} / Faces: ${faces.length} (outer face excluded)`;
                network.redraw();
            } catch (e) {
                errorDiv.textContent = e.message;
            }
        }

        async function refreshSavedList() {
            const select = document.getElementById('load-select');
            select.innerHTML = '';
            try {
                const res = await fetch('/graph/list');
                if (!res.ok) throw new Error('API error');
                const data = await res.json();
                const files = data.files || [];
                files.forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    select.appendChild(opt);
                });
            } catch (e) {
                // no-op
            }
        }

        async function saveGraph() {
            const errorDiv = document.getElementById('error');
            const infoDiv = document.getElementById('info');
            errorDiv.textContent = '';
            if (!currentGraph) {
                errorDiv.textContent = 'Please generate a graph first';
                return;
            }
            const name = document.getElementById('save-name').value.trim();
            if (!name) {
                errorDiv.textContent = 'Please enter a save name';
                return;
            }
            try {
                syncPositionsFromNetwork();
                const res = await fetch('/graph/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name,
                        num_vertices: currentGraph.num_vertices,
                        edges: currentGraph.edges,
                        positions: currentGraph.positions,
                    }),
                });
                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.detail || 'API error');
                }
                const data = await res.json();
                infoDiv.textContent = `Saved: ${data.name}`;
                await refreshSavedList();
            } catch (e) {
                errorDiv.textContent = e.message;
            }
        }

        async function loadGraph() {
            const errorDiv = document.getElementById('error');
            const infoDiv = document.getElementById('info');
            errorDiv.textContent = '';
            const select = document.getElementById('load-select');
            const name = select.value;
            if (!name) {
                errorDiv.textContent = 'Please select a graph to load';
                return;
            }
            try {
                const res = await fetch(`/graph/load/${encodeURIComponent(name)}`);
                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.detail || 'API error');
                }
                const data = await res.json();
                currentGraph = data;
                renderGraph(data);
                infoDiv.textContent = `Loaded: ${name}`;
            } catch (e) {
                errorDiv.textContent = e.message;
            }
        }

        function drawFaces(ctx) {
            if (!facePolygons || !faceColors || !network) return;
            const positions = network.getPositions();
            ctx.save();
            ctx.globalAlpha = 0.45;
            for (let i = 0; i < facePolygons.length; i++) {
                const face = facePolygons[i];
                const color = faceColors[i];
                if (!face || face.length < 3) continue;
                const p0 = positions[face[0]];
                if (!p0) continue;
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                for (let j = 1; j < face.length; j++) {
                    const p = positions[face[j]];
                    if (!p) continue;
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
            }
            ctx.restore();
        }

        function drawOrientationOverlay(ctx) {
            if (!showOrientationArrows || !regionBoundaryArrows || !network) return;
            const positions = network.getPositions();
            ctx.save();
            ctx.lineWidth = 2.0;
            ctx.strokeStyle = '#66e3ff';
            ctx.fillStyle = '#66e3ff';
            ctx.shadowColor = '#66e3ff';
            ctx.shadowBlur = 6;
            for (const e of regionBoundaryArrows) {
                const p0 = positions[e.from];
                const p1 = positions[e.to];
                if (!p0 || !p1) continue;
                drawArrow(ctx, p0, p1, 18, 7, 0.52);
                drawFlowTrail(ctx, p0, p1, 0.42, 10, '#66e3ff');
            }
            ctx.restore();
            if (!optimizedInternalArrows || optimizedInternalArrows.length === 0) return;
            ctx.save();
            ctx.lineWidth = 2.8;
            ctx.strokeStyle = '#ff4df0';
            ctx.fillStyle = '#ff4df0';
            ctx.shadowColor = '#ff4df0';
            ctx.shadowBlur = 12;
            for (const e of optimizedInternalArrows) {
                const p0 = positions[e.from];
                const p1 = positions[e.to];
                if (!p0 || !p1) continue;
                drawArrow(ctx, p0, p1, 28, 11, 0.56);
                drawFlowTrail(ctx, p0, p1, 0.56, 14, '#ff4df0');
            }
            ctx.restore();
        }

        function drawArrow(ctx, from, to, length, headSize, offsetRatio = 0.5) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const d = Math.hypot(dx, dy);
            if (d < 1e-6) return;
            const ux = dx / d;
            const uy = dy / d;
            const mx = from.x + dx * offsetRatio;
            const my = from.y + dy * offsetRatio;
            const ex = mx + ux * length;
            const ey = my + uy * length;
            ctx.beginPath();
            ctx.moveTo(mx, my);
            ctx.lineTo(ex, ey);
            ctx.stroke();
            const hx = ex - ux * headSize;
            const hy = ey - uy * headSize;
            const px = -uy * headSize * 0.7;
            const py = ux * headSize * 0.7;
            ctx.beginPath();
            ctx.moveTo(ex, ey);
            ctx.lineTo(hx + px, hy + py);
            ctx.lineTo(hx - px, hy - py);
            ctx.closePath();
            ctx.fill();
        }

        function drawFlowTrail(ctx, from, to, speed, step, color) {
            const now = performance.now() * 0.001;
            const phase = (now * speed) % 1;
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const d = Math.hypot(dx, dy);
            if (d < 30) return;
            const ux = dx / d;
            const uy = dy / d;
            const markerCount = Math.max(2, Math.floor(d / 90));
            for (let i = 0; i < markerCount; i++) {
                const t = (phase + i / markerCount) % 1;
                const px = from.x + dx * t;
                const py = from.y + dy * t;
                const x0 = px - ux * step * 0.85;
                const y0 = py - uy * step * 0.85;
                const x1 = px + ux * step * 0.85;
                const y1 = py + uy * step * 0.85;
                ctx.save();
                ctx.globalAlpha = 0.95;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2.4;
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.stroke();
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(px, py, 2.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function ensureArrowAnimation() {
            if (animationFrameId !== null) return;
            const loop = () => {
                if (network && showOrientationArrows) {
                    network.redraw();
                }
                animationFrameId = requestAnimationFrame(loop);
            };
            animationFrameId = requestAnimationFrame(loop);
        }

        function randomPastel(seed) {
            const x = Math.sin(seed * 999 + 13) * 10000;
            const r = Math.floor(180 + (x - Math.floor(x)) * 60);
            const g = Math.floor(180 + (Math.sin(seed * 123 + 7) + 1) * 30);
            const b = Math.floor(180 + (Math.sin(seed * 321 + 11) + 1) * 30);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function randomRegionCount(minK, maxK) {
            if (maxK <= minK) return minK;
            return Math.floor(Math.random() * (maxK - minK + 1)) + minK;
        }

        function assignRegionsBySharedEdges(faces, desiredCount) {
            const faceCount = faces.length;
            const regions = new Array(faceCount).fill(-1);

            // Build adjacency by shared edges
            const edgeToFaces = new Map();
            for (let i = 0; i < faceCount; i++) {
                const face = faces[i];
                for (let j = 0; j < face.length; j++) {
                    const a = face[j];
                    const b = face[(j + 1) % face.length];
                    const key = `${Math.min(a, b)}-${Math.max(a, b)}`;
                    if (!edgeToFaces.has(key)) edgeToFaces.set(key, []);
                    edgeToFaces.get(key).push(i);
                }
            }

            const adj = Array.from({ length: faceCount }, () => new Set());
            edgeToFaces.forEach(list => {
                if (list.length < 2) return;
                for (let i = 0; i < list.length; i++) {
                    for (let j = i + 1; j < list.length; j++) {
                        adj[list[i]].add(list[j]);
                        adj[list[j]].add(list[i]);
                    }
                }
            });

            // Find connected components in face adjacency graph
            const components = [];
            const visited = new Array(faceCount).fill(false);
            for (let i = 0; i < faceCount; i++) {
                if (visited[i]) continue;
                const stack = [i];
                visited[i] = true;
                const comp = [];
                while (stack.length) {
                    const v = stack.pop();
                    comp.push(v);
                    adj[v].forEach(nb => {
                        if (!visited[nb]) {
                            visited[nb] = true;
                            stack.push(nb);
                        }
                    });
                }
                components.push(comp);
            }

            const compCount = components.length;
            const maxK = faceCount;
            let regionCount;
            if (desiredCount !== null && desiredCount !== undefined) {
                regionCount = Math.max(compCount, Math.min(maxK, desiredCount));
            } else {
                regionCount = randomRegionCount(compCount, maxK);
            }

            // Allocate region counts per component (at least 1 each, capped by size)
            const compRegions = components.map(c => 1);
            let remaining = regionCount - compCount;
            while (remaining > 0) {
                const idx = Math.floor(Math.random() * compRegions.length);
                if (compRegions[idx] < components[idx].length) {
                    compRegions[idx]++;
                    remaining--;
                }
            }

            // Assign regions within each component by BFS growth
            let regionBase = 0;
            for (let ci = 0; ci < components.length; ci++) {
                const comp = components[ci];
                const k = compRegions[ci];

                // shuffle faces in component
                const compFaces = comp.slice();
                for (let i = compFaces.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [compFaces[i], compFaces[j]] = [compFaces[j], compFaces[i]];
                }

                const seeds = compFaces.slice(0, k);
                const frontiers = Array.from({ length: k }, () => []);
                for (let r = 0; r < k; r++) {
                    const f = seeds[r];
                    regions[f] = regionBase + r;
                    frontiers[r].push(f);
                }

                let assigned = k;
                while (assigned < comp.length) {
                    let progressed = false;
                    for (let r = 0; r < k; r++) {
                        if (frontiers[r].length === 0) continue;
                        const current = frontiers[r].shift();
                        const neighbors = Array.from(adj[current]).filter(v => regions[v] === -1);
                        for (let i = neighbors.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [neighbors[i], neighbors[j]] = [neighbors[j], neighbors[i]];
                        }
                        for (const nb of neighbors) {
                            regions[nb] = regionBase + r;
                            frontiers[r].push(nb);
                            assigned++;
                            progressed = true;
                        }
                    }

                    if (!progressed) {
                        // Fallback: assign any remaining face to a random region to avoid infinite loop
                        const remainingIdx = comp.find(v => regions[v] === -1);
                        if (remainingIdx === undefined) break;
                        const r = Math.floor(Math.random() * k);
                        regions[remainingIdx] = regionBase + r;
                        frontiers[r].push(remainingIdx);
                        assigned++;
                    }
                }

                regionBase += k;
            }

            return { regions, regionCount };
        }

        function assignRegionsGreedyBoundary(facesAll, outerIdx, positions) {
            const faceCountAll = facesAll.length;
            if (outerIdx === null || outerIdx === undefined) {
                return assignRegionsGreedyNoCycles(facesAll, positions);
            }

            const internalIds = [];
            for (let i = 0; i < faceCountAll; i++) {
                if (i !== outerIdx) internalIds.push(i);
            }
            const m = internalIds.length;
            const idToInternal = new Map();
            internalIds.forEach((id, idx) => idToInternal.set(id, idx));

            const outerVertices = new Set(facesAll[outerIdx] || []);

            const edgeToFaces = new Map();
            for (let i = 0; i < faceCountAll; i++) {
                const face = facesAll[i];
                for (let j = 0; j < face.length; j++) {
                    const a = face[j];
                    const b = face[(j + 1) % face.length];
                    const key = `${Math.min(a, b)}-${Math.max(a, b)}`;
                    if (!edgeToFaces.has(key)) edgeToFaces.set(key, []);
                    edgeToFaces.get(key).push(i);
                }
            }

            const adj = Array.from({ length: m }, () => new Set());
            edgeToFaces.forEach(list => {
                if (list.length < 2) return;
                for (let i = 0; i < list.length; i++) {
                    for (let j = i + 1; j < list.length; j++) {
                        const a = list[i];
                        const b = list[j];
                        if (a === outerIdx || b === outerIdx) continue;
                        const ia = idToInternal.get(a);
                        const ib = idToInternal.get(b);
                        adj[ia].add(ib);
                        adj[ib].add(ia);
                    }
                }
            });

            const facesInternal = internalIds.map(id => facesAll[id]);
            const areas = facesInternal.map(face => Math.abs(polygonArea(face, positions)));

            // incident internal faces per vertex
            const incident = new Map();
            for (let i = 0; i < m; i++) {
                const face = facesInternal[i];
                for (const v of face) {
                    if (!incident.has(v)) incident.set(v, new Set());
                    incident.get(v).add(i);
                }
            }

            const regions = new Array(m).fill(-1);
            const unassigned = new Set(Array.from({ length: m }, (_, i) => i));

            function wouldCreateInteriorVertex(regionFaces, candidate) {
                const next = new Set(regionFaces);
                next.add(candidate);
                const face = facesInternal[candidate];
                for (const v of face) {
                    if (outerVertices.has(v)) continue;
                    const inc = incident.get(v);
                    if (!inc) continue;
                    let allIn = true;
                    inc.forEach(f => {
                        if (!next.has(f)) allIn = false;
                    });
                    if (allIn) return true;
                }
                return false;
            }

            function boundaryVertexCount(regionFaces) {
                const verts = new Set();
                regionFaces.forEach(f => {
                    facesInternal[f].forEach(v => verts.add(v));
                });
                let count = 0;
                verts.forEach(v => {
                    if (outerVertices.has(v)) {
                        count++;
                        return;
                    }
                    const inc = incident.get(v);
                    let allIn = true;
                    inc.forEach(f => {
                        if (!regionFaces.has(f)) allIn = false;
                    });
                    if (!allIn) count++;
                });
                return count;
            }

            let regionId = 0;
            while (unassigned.size > 0) {
                // seed: unassigned face with largest area
                let seed = -1;
                let bestArea = -1;
                unassigned.forEach(i => {
                    if (areas[i] > bestArea) {
                        bestArea = areas[i];
                        seed = i;
                    }
                });
                if (seed === -1) break;

                const regionFaces = new Set([seed]);
                regions[seed] = regionId;
                unassigned.delete(seed);

                let grew = true;
                while (grew) {
                    grew = false;
                    let bestCandidate = -1;
                    let bestBoundary = -1;
                    let bestAreaLocal = -1;

                    const candidates = [];
                    unassigned.forEach(i => {
                        let adjacent = false;
                        adj[i].forEach(nb => {
                            if (regionFaces.has(nb)) adjacent = true;
                        });
                        if (adjacent) candidates.push(i);
                    });

                    for (const cand of candidates) {
                        if (wouldCreateInteriorVertex(regionFaces, cand)) continue;
                        const next = new Set(regionFaces);
                        next.add(cand);
                        const bcount = boundaryVertexCount(next);
                        if (bcount > bestBoundary || (bcount === bestBoundary && areas[cand] > bestAreaLocal)) {
                            bestBoundary = bcount;
                            bestAreaLocal = areas[cand];
                            bestCandidate = cand;
                        }
                    }

                    if (bestCandidate !== -1) {
                        regionFaces.add(bestCandidate);
                        regions[bestCandidate] = regionId;
                        unassigned.delete(bestCandidate);
                        grew = true;
                    }
                }

                regionId++;
            }

            return { regions, regionCount: regionId };
        }

        function assignRegionsGreedyNoCycles(faces, positions) {
            const faceCount = faces.length;
            const regions = new Array(faceCount).fill(-1);

            const edgeToFaces = new Map();
            for (let i = 0; i < faceCount; i++) {
                const face = faces[i];
                for (let j = 0; j < face.length; j++) {
                    const a = face[j];
                    const b = face[(j + 1) % face.length];
                    const key = `${Math.min(a, b)}-${Math.max(a, b)}`;
                    if (!edgeToFaces.has(key)) edgeToFaces.set(key, []);
                    edgeToFaces.get(key).push(i);
                }
            }

            const adj = Array.from({ length: faceCount }, () => new Set());
            edgeToFaces.forEach(list => {
                if (list.length < 2) return;
                for (let i = 0; i < list.length; i++) {
                    for (let j = i + 1; j < list.length; j++) {
                        adj[list[i]].add(list[j]);
                        adj[list[j]].add(list[i]);
                    }
                }
            });

            const areas = faces.map(face => Math.abs(polygonArea(face, positions)));
            const unassigned = new Set(Array.from({ length: faceCount }, (_, i) => i));

            let regionId = 0;
            while (unassigned.size > 0) {
                let seed = -1;
                let bestArea = -1;
                unassigned.forEach(i => {
                    if (areas[i] > bestArea) {
                        bestArea = areas[i];
                        seed = i;
                    }
                });
                if (seed === -1) break;

                regions[seed] = regionId;
                unassigned.delete(seed);

                let grew = true;
                while (grew) {
                    grew = false;
                    let bestFace = -1;
                    let bestFaceArea = -1;
                    unassigned.forEach(i => {
                        let neighborCount = 0;
                        adj[i].forEach(nb => {
                            if (regions[nb] === regionId) neighborCount++;
                        });
                        if (neighborCount === 0) return;
                        if (neighborCount >= 2) return;
                        if (areas[i] > bestFaceArea) {
                            bestFaceArea = areas[i];
                            bestFace = i;
                        }
                    });

                    if (bestFace !== -1) {
                        regions[bestFace] = regionId;
                        unassigned.delete(bestFace);
                        grew = true;
                    }
                }

                regionId++;
            }

            return { regions, regionCount: regionId };
        }

        function polygonArea(face, positions) {
            let area = 0;
            for (let i = 0; i < face.length; i++) {
                const a = positions[face[i]] ?? positions[String(face[i])];
                const b = positions[face[(i + 1) % face.length]] ?? positions[String(face[(i + 1) % face.length])];
                area += a.x * b.y - b.x * a.y;
            }
            return area * 0.5;
        }

        async function showOrientation() {
            const errorDiv = document.getElementById('error');
            const infoDiv = document.getElementById('info');
            errorDiv.textContent = '';
            if (!currentGraph) {
                errorDiv.textContent = 'Please generate a graph first';
                return;
            }
            if (!currentFaceRegions || !latestFacesAll) {
                errorDiv.textContent = 'Please run region splitting first';
                return;
            }
            const seedFace = parseInt(document.getElementById('seed-face').value);
            const orientation = document.getElementById('seed-orientation').value;
            let seedFaceIndex = null;
            if (!isNaN(seedFace) && currentFaceRegions && latestInternalFaceIds) {
                const localIdx = currentFaceRegions.findIndex(r => r === seedFace);
                if (localIdx !== -1) {
                    seedFaceIndex = latestInternalFaceIds[localIdx];
                }
            }
            try {
                const res = await fetch('/graph/faces', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        num_vertices: currentGraph.num_vertices,
                        edges: currentGraph.edges,
                        positions: currentGraph.positions,
                        seed_face_index: seedFaceIndex,
                        seed_orientation: orientation,
                    }),
                });

                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.detail || 'API error');
                }

                const data = await res.json();
                orientedFaces = data.oriented_faces || null;
                orientedOuterIdx = data.outer_face_index;
                showOrientationArrows = true;
                optimizedInternalArrows = null;
                regionBoundaryArrows = buildRegionBoundaryArrows(
                    data.oriented_faces || data.faces || [],
                    data.outer_face_index,
                    currentFaceRegions,
                    isNaN(seedFace) ? null : seedFace
                );
                infoDiv.textContent = `Orientation displayed (seed region: ${isNaN(seedFace) ? '-' : seedFace} / ${orientation})`;
                network.redraw();
            } catch (e) {
                errorDiv.textContent = e.message;
            }
        }

        function getUniqueBoundaryOrientedEdges(boundaryArrows) {
            const map = new Map();
            for (const e of (boundaryArrows || [])) {
                const a = Math.min(e.from, e.to);
                const b = Math.max(e.from, e.to);
                const key = `${a}-${b}`;
                const sign = (e.from === a && e.to === b) ? 1 : -1;
                if (!map.has(key)) {
                    map.set(key, sign);
                    continue;
                }
                if (map.get(key) !== sign) {
                    throw new Error(`Boundary edge orientation conflict: ${key}`);
                }
            }
            const fixed = [];
            map.forEach((sign, key) => {
                const [aStr, bStr] = key.split('-');
                const a = parseInt(aStr, 10);
                const b = parseInt(bStr, 10);
                if (sign === 1) {
                    fixed.push({ source: a, target: b });
                } else {
                    fixed.push({ source: b, target: a });
                }
            });
            return fixed;
        }

        async function optimizeInternalOrientation() {
            const errorDiv = document.getElementById('error');
            const infoDiv = document.getElementById('info');
            errorDiv.textContent = '';
            if (!currentGraph) {
                errorDiv.textContent = 'Please generate a graph first';
                return;
            }
            if (!regionBoundaryArrows || regionBoundaryArrows.length === 0) {
                errorDiv.textContent = 'Please run orientation display first';
                return;
            }

            try {
                const fixedEdges = getUniqueBoundaryOrientedEdges(regionBoundaryArrows);
                const res = await fetch('/graph/optimize-orientation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        num_vertices: currentGraph.num_vertices,
                        edges: currentGraph.edges,
                        fixed_edges: fixedEdges,
                        max_iterations: 1600,
                    }),
                });

                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.detail || 'API error');
                }
                const data = await res.json();

                const fixedKey = new Set(
                    fixedEdges.map(e => `${Math.min(e.source, e.target)}-${Math.max(e.source, e.target)}`)
                );
                optimizedInternalArrows = (data.directed_edges || []).filter(e => {
                    const key = `${Math.min(e.source, e.target)}-${Math.max(e.source, e.target)}`;
                    return !fixedKey.has(key);
                }).map(e => ({ from: e.source, to: e.target }));

                const m = data.metrics || {};
                const uvCount = m.unreachable_vertex_count ?? 0;
                const uvList = m.unreachable_vertices || [];
                infoDiv.textContent = [
                    `Internal orientation optimized (red arrows: ${optimizedInternalArrows.length})`,
                    `Average distance=${(m.average_distance ?? 0).toFixed(2)}`,
                    `Unreachable pairs=${m.unreachable_pairs ?? 0}`,
                    `Unreachable vertices=${uvCount}${uvCount > 0 ? ` (${uvList.join(',')})` : ''}`,
                    `Load square sum=${(m.load_square_sum ?? 0).toFixed(1)}`,
                    `Max load=${(m.max_load ?? 0).toFixed(1)}`,
                ].join(' / ');
                network.redraw();
            } catch (e) {
                errorDiv.textContent = e.message;
            }
        }

        function buildRegionBoundaryArrows(orientedFacesAll, outerIdx, regions, seedRegion) {
            if (!orientedFacesAll || regions == null) return [];
            const internalFaceIds = [];
            for (let i = 0; i < orientedFacesAll.length; i++) {
                if (i !== outerIdx) internalFaceIds.push(i);
            }
            if (internalFaceIds.length !== regions.length) return [];

            const orientedInternal = internalFaceIds.map(id => orientedFacesAll[id]);
            const edgeToFaces = new Map();
            for (let i = 0; i < orientedInternal.length; i++) {
                const face = orientedInternal[i];
                for (let j = 0; j < face.length; j++) {
                    const a = face[j];
                    const b = face[(j + 1) % face.length];
                    const key = `${Math.min(a, b)}-${Math.max(a, b)}`;
                    if (!edgeToFaces.has(key)) edgeToFaces.set(key, []);
                    edgeToFaces.get(key).push(i);
                }
            }

            const boundaryByRegion = new Map();
            for (let i = 0; i < orientedInternal.length; i++) {
                const face = orientedInternal[i];
                const r = regions[i];
                if (!boundaryByRegion.has(r)) boundaryByRegion.set(r, []);
                for (let j = 0; j < face.length; j++) {
                    const a = face[j];
                    const b = face[(j + 1) % face.length];
                    const key = `${Math.min(a, b)}-${Math.max(a, b)}`;
                    const neigh = edgeToFaces.get(key) || [];
                    let boundary = true;
                    if (neigh.length === 2) {
                        const other = neigh[0] === i ? neigh[1] : neigh[0];
                        if (regions[other] === r) boundary = false;
                    }
                    if (boundary) boundaryByRegion.get(r).push({ from: a, to: b, key });
                }
            }

            // Reconstruct one-stroke boundary cycle(s) per region.
            let arrows = [];
            boundaryByRegion.forEach((edges, r) => {
                if (edges.length === 0) return;
                const outByNode = new Map();
                edges.forEach(e => {
                    if (!outByNode.has(e.from)) outByNode.set(e.from, []);
                    outByNode.get(e.from).push(e);
                });

                const used = new Set();
                for (const e0 of edges) {
                    if (used.has(e0.key + "|" + e0.from + ">" + e0.to)) continue;
                    let cur = e0;
                    let guard = 0;
                    while (cur && guard < edges.length + 5) {
                        const mark = cur.key + "|" + cur.from + ">" + cur.to;
                        if (used.has(mark)) break;
                        used.add(mark);
                        arrows.push({ from: cur.from, to: cur.to, region: r, key: cur.key });
                        const nextList = outByNode.get(cur.to) || [];
                        let next = null;
                        for (const cand of nextList) {
                            const candMark = cand.key + "|" + cand.from + ">" + cand.to;
                            if (!used.has(candMark)) {
                                next = cand;
                                break;
                            }
                        }
                        cur = next;
                        guard += 1;
                    }
                }
            });

            // Align region orientations so shared boundaries point in the same direction.
            const regionsList = Array.from(boundaryByRegion.keys());
            const regionSet = new Set(regionsList);
            const root = regionSet.has(seedRegion) ? seedRegion : regionsList[0];
            const flip = new Map(); // 1 keep, -1 reverse
            const adj = new Map();
            regionsList.forEach(r => adj.set(r, []));

            const edgeByRegion = new Map();
            regionsList.forEach(r => edgeByRegion.set(r, new Map()));
            arrows.forEach(a => {
                const canonicalDir = (a.from < a.to) ? 1 : -1;
                edgeByRegion.get(a.region).set(a.key, canonicalDir);
            });

            const keyRegions = new Map();
            arrows.forEach(a => {
                if (!keyRegions.has(a.key)) keyRegions.set(a.key, new Set());
                keyRegions.get(a.key).add(a.region);
            });
            keyRegions.forEach((rs, key) => {
                const arr = Array.from(rs);
                for (let i = 0; i < arr.length; i++) {
                    for (let j = i + 1; j < arr.length; j++) {
                        const r1 = arr[i];
                        const r2 = arr[j];
                        const d1 = edgeByRegion.get(r1).get(key);
                        const d2 = edgeByRegion.get(r2).get(key);
                        const desired = d1 * d2; // flip[r2] should be flip[r1] * desired
                        adj.get(r1).push({ nb: r2, desired });
                        adj.get(r2).push({ nb: r1, desired });
                    }
                }
            });

            if (root !== undefined) {
                flip.set(root, 1);
                const q = [root];
                while (q.length) {
                    const r = q.shift();
                    const fr = flip.get(r);
                    for (const { nb, desired } of (adj.get(r) || [])) {
                        if (flip.has(nb)) continue;
                        flip.set(nb, fr * desired);
                        q.push(nb);
                    }
                }
            }
            regionsList.forEach(r => {
                if (!flip.has(r)) flip.set(r, 1);
            });

            arrows = arrows.map(a => {
                if (flip.get(a.region) === -1) {
                    return { ...a, from: a.to, to: a.from };
                }
                return a;
            });

            return arrows;
        }

        function syncPositionsFromNetwork() {
            if (!network || !currentGraph) return;
            const positions = network.getPositions();
            const updated = {};
            Object.keys(positions).forEach(key => {
                const id = parseInt(key, 10);
                const p = positions[key];
                updated[id] = { x: p.x, y: p.y };
            });
            currentGraph.positions = updated;
        }

        refreshSavedList();
    </script>
</body>
</html>
